---
- name: Enforce CIS 3.4.2.2 loopback firewall rules (idempotent version)
  hosts: all
  become: true
  gather_facts: yes

  vars:
    ts: "{{ lookup('pipe', 'date +%Y%m%d-%H%M%S') }}"
    restore_from_latest_backup: false
    backup_dir: "/root"

  pre_tasks:
    - name: Gather service facts (systemd)
      ansible.builtin.service_facts:

    - name: Read net.ipv6.conf.all.disable_ipv6 (0 = IPv6 enabled)
      ansible.builtin.command: sysctl -n net.ipv6.conf.all.disable_ipv6
      register: ipv6_flag
      changed_when: false
      failed_when: false

    - name: Set fact ipv6_disabled
      ansible.builtin.set_fact:
        ipv6_disabled: "{{ (ipv6_flag.stdout | default('1')).strip() }}"

    - name: Determine active firewall utility
      ansible.builtin.set_fact:
        fw_type: >-
          {{ 'firewalld'
             if ('firewalld.service' in ansible_facts.services and
                  ansible_facts.services['firewalld.service'].status == 'enabled')
             else 'nftables'
             if ('nftables.service' in ansible_facts.services and
                  ansible_facts.services['nftables.service'].status == 'enabled')
             else 'none' }}

    - name: Fail if both or neither firewall utilities are enabled
      ansible.builtin.fail:
        msg: >-
          Exactly one of firewalld or nftables must be enabled (CIS 3.4.1).
      when: fw_type == 'none' or
            ( 'firewalld.service' in ansible_facts.services and
              'nftables.service' in ansible_facts.services and
              ansible_facts.services['firewalld.service'].status == 'enabled' and
              ansible_facts.services['nftables.service'].status == 'enabled')

  tasks:

    - name: Backup current firewall config
      block:
        - name: Backup firewalld runtime config
          ansible.builtin.command: firewall-cmd --runtime-to-permanent
          when: fw_type == 'firewalld'

        - name: Archive /etc/firewalld
          ansible.builtin.archive:
            path: /etc/firewalld
            dest: "{{ backup_dir }}/fw-backup-{{ ts }}.tar.gz"
            format: gz
          when: fw_type == 'firewalld'

        - name: Backup nftables ruleset
          ansible.builtin.shell: "nft list ruleset > {{ backup_dir }}/fw-backup-{{ ts }}.nft"
          changed_when: false
          when: fw_type == 'nftables'

      when: not restore_from_latest_backup

    - name: Restore firewall from backup
      block:
        - name: Find most recent backup
          ansible.builtin.find:
            paths: "{{ backup_dir }}"
            patterns: "fw-backup-*.tar.gz,fw-backup-*.nft"
            recurse: no
            age_stamp: mtime
          register: backup_files

        - name: Fail if no backup found
          ansible.builtin.fail:
            msg: "No backup files found in {{ backup_dir }}."
          when: backup_files.matched == 0

        - name: Restore firewalld backup
          ansible.builtin.unarchive:
            src: "{{ backup_files.files | sort(attribute='mtime') | last.path }}"
            dest: /
            extra_opts: [--strip-components=3]
          when: fw_type == 'firewalld'

        - name: Restore nftables backup
          ansible.builtin.copy:
            src: "{{ backup_files.files | sort(attribute='mtime') | last.path }}"
            dest: "{{ backup_dir }}/restore.nft"
          when: fw_type == 'nftables'

        - name: Load restored nftables ruleset
          ansible.builtin.command: "nft -f {{ backup_dir }}/restore.nft"
          when: fw_type == 'nftables'

      when: restore_from_latest_backup

    - name: Enforce loopback firewall rules (firewalld)
      block:
        - name: Ensure loopback interface in trusted zone
          ansible.builtin.command: firewall-cmd --permanent --query-interface=lo
          register: fwd_lo_in_trusted
          failed_when: false
          changed_when: false

        - name: Add loopback interface to trusted zone
          ansible.builtin.command: firewall-cmd --permanent --zone=trusted --add-interface=lo
          when: fwd_lo_in_trusted.rc != 0
          notify: reload firewalld

        - name: Check IPv4 rich rule exists
          ansible.builtin.command: >
            firewall-cmd --permanent --query-rich-rule='rule family="ipv4" source address="127.0.0.1" destination not address="127.0.0.1" drop'
          register: fwd_ipv4_rule_exists
          failed_when: false
          changed_when: false

        - name: Add IPv4 rich rule
          ansible.builtin.command: >
            firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="127.0.0.1" destination not address="127.0.0.1" drop'
          when: fwd_ipv4_rule_exists.rc != 0
          notify: reload firewalld

        - name: Check IPv6 rich rule exists
          ansible.builtin.command: >
            firewall-cmd --permanent --query-rich-rule='rule family="ipv6" source address="::1" destination not address="::1" drop'
          register: fwd_ipv6_rule_exists
          failed_when: false
          changed_when: false
          when: ipv6_disabled == '0'

        - name: Add IPv6 rich rule
          ansible.builtin.command: >
            firewall-cmd --permanent --add-rich-rule='rule family="ipv6" source address="::1" destination not address="::1" drop'
          when: ipv6_disabled == '0' and fwd_ipv6_rule_exists.rc != 0
          notify: reload firewalld

      when: fw_type == 'firewalld'

    - name: Enforce loopback firewall rules (nftables)
      block:
        - name: Check if loopback accept rule exists
          ansible.builtin.shell: nft list ruleset | grep -q 'iif "lo" accept'
          register: nft_lo_exists
          failed_when: false
          changed_when: false

        - name: Add loopback accept rule
          ansible.builtin.command: nft add rule inet filter input iif lo accept
          when: nft_lo_exists.rc != 0
          notify: reload nftables

        - name: Check IPv4 loopback spoof rule exists
          ansible.builtin.shell: nft list ruleset | grep -q 'ip saddr 127.0.0.0/8 counter drop'
          register: nft_ipv4_exists
          failed_when: false
          changed_when: false

        - name: Add IPv4 loopback spoof drop rule
          ansible.builtin.command: nft add rule inet filter input ip saddr 127.0.0.0/8 counter drop
          when: nft_ipv4_exists.rc != 0
          notify: reload nftables

        - name: Check IPv6 loopback spoof rule exists
          ansible.builtin.shell: nft list ruleset | grep -q 'ip6 saddr ::1 counter drop'
          register: nft_ipv6_exists
          failed_when: false
          changed_when: false
          when: ipv6_disabled == '0'

        - name: Add IPv6 loopback spoof drop rule
          ansible.builtin.command: nft add rule inet filter input ip6 saddr ::1 counter drop
          when: ipv6_disabled == '0' and nft_ipv6_exists.rc != 0
          notify: reload nftables

      when: fw_type == 'nftables'

  handlers:
    - name: reload firewalld
      ansible.builtin.command: firewall-cmd --reload
      when: fw_type == 'firewalld'

    - name: reload nftables
      ansible.builtin.command: nft -f /etc/nftables.conf
      when: fw_type == 'nftables'

